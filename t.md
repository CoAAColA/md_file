由于我们无法修改事务类，无法在事务类内部维护其所等待的锁集合，如果我们在`lock_manager`类内部维护这样一个集合的话，会限制并发性，因此在`aborted`时我们直接遍历所有资源的等待队列，如果遇到对应事务的`request`，则将该request移除出队列。

如果先释放已持有的锁，那么可能会造成aborted事务等待队列被正常授予锁，造成错误。或者后台线程等待lock_request_queue的lock，事务线程等待事务的lock，造成死锁。

如果先终结等待队列，那么可能导致事务线程正常进行下去，再次触发aborted，导致持有的资源被解锁两次，造成异常。